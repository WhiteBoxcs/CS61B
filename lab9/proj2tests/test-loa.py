#!/usr/bin/env python3
# -*-Python-*-

# Author: P. N. Hilfinger

# For usage, see Usage procedure (or invoke the command without arguments).
# Feel free to adapt this script to your needs.

import sys, os, re
import threading
from subprocess import Popen, PIPE
import signal
from queue import Queue, Empty, Full
import time
from getopt import getopt
import traceback
   		      
MAX_QUEUE_SIZE = 8192

DEFAULT_TIMEOUT = 15.0
QUANTUM = 0.125

def Dbg(msg, *args):
    print(msg % args, file=sys.stderr)
    sys.stderr.flush()

def Log(msg, *args):
    if log:
        print(msg % args, file=log)

def Usage():
    print("""\
Usage: test-loa OPTIONS FILE.inp ...

   For each FILE.inp, performs the indicated scripts, and compares any board
   output (between "===" markers) with the file FILE.std, if present.

   Each FILE.inp should contain specifications for one run of loa, as follows:
     * The file has the form
            # Any number of comment lines, starting with #.
            COMMAND1
            COMMAND2
            ===#1===
            INPUT1
            ===#2===
            INPUT2
      * COMMAND1 and COMMAND2 are the command lines to start the
        two programs.  COMMAND2 can be None, indicating that
        there is only one program.
      * INPUT1 and INPUT2 are the commands to be fed to the programs.  INPUT2
        is ignored if there is only one program.
        The commands may be the usual inputs to loa, as well as the following
        special commands:
            %ib    Wait for a black move from the other program and insert
                   it here.
            %iw    Wait for a white move from the other program and insert
                   it here.
            %mb    Wait for this program to print a black move, and send it to
                   the other program.
            %mw    Wait for this program to print a white move, and send it to
                   the other program.
            %bw    Wait for a sequence of alternating black and white moves from
                   this program, starting with black, up to an announcement of
                   a winner (for use with two AIs).
            %wb    As for %bw, but starting with a white move.
            %ib... As for %ib, and then wait for a white move from this
                   program, send it to the other program, and then repeat
                   these steps up to an announcement of a winner.
            %iw... As for %iw, and then wait for a black move from this
                   program, send it to the other program, and then repeat
                   these steps up to an announcement of a winner.
            %e     Indicates a point where test-loa expects an announcement
                   of a winner (for either side) or tie.
            %eb    As for %e, but expects to see "Black wins."
            %ew    As for %e, but expects to see "White wins."
            %et    As for %e, but expects to see "Tie game."
            %ae    As for %e, but also prints winner.
        All output from a program that requires a response from the other
        program (such as W:b6-d4) must be anticipated by one of these
        special commands.  Otherwise, the test is liable to hang, since the
        other program will never receive the necessary input.

 OPTIONS:

   --time=MINUTES Default time limit for each side's moves in minutes.

   --show=N    Display up to N input files that cause failures.

   --std       For each input file, F.in, create file F.out.tmp containing
               the output generated by the programs tested.

   --verbose   Same as --verbosity=1

   --verbosity=N  Sets verbosity level to N.""", file=sys.stderr)
    sys.exit(1)

        
def Match(patn, text):
    global _match
    _match = re.match(patn, text)
    return _match

def Group(i):
    return _match.group(i)

def Open(name):
    try:
        return open(name)
    except:
        return None

def Close(f):
    try:
        f.close()
    except:
        pass


def output_queuer(id, out_stream):
    """Return a Queue that gathers the lines of output from OUT_STREAM,
    followed by an empty string."""
    def transfer():
        while True:
            try:
                line = out_stream.readline()
                if verbose & 1:
                    Msg("<%s: %s", id, line)
                queue.put(line)
            except:
                return
            if line == "":
                return
    queue = Queue(MAX_QUEUE_SIZE)
    task = threading.Thread(target=transfer)
    task.setDaemon(True)
    task.start()
    return queue

def queue_writer(output, Q = None):
    """Set up a thread to write the contents of Q to OUTPUT.  The thread is a
    daemon, and therefore need not be shut down.  If defaulted, a new queue
    of unlimited size is used.  Returns the queue."""
    def transfer():
        while True:
            line = Q.get(True)
            output.write(line)
    Q = Q or Queue(MAX_QUEUE_SIZE)
    task = threading.Thread(target=transfer)
    task.setDaemon(True)
    task.start()
    return Q

class Move_Error(Exception):
    pass

class Spec_Error(Exception):
    pass

class Win(Exception):
    pass

msgs = queue_writer(sys.stderr)

def Msg(format, *args):
    msg = format % args
    if len(msg) == 0 or msg[-1] != '\n':
        msg += "\\\n"
    msgs.put(format % args)

class Prog(object):
    """Represents one running game program."""

    def __init__(self, id, command, inputs, time_limit):
# ??    command = Popen('echo ' + command, shell=True,    
# ??                    stdin=PIPE, stdout=PIPE, stderr=PIPE).communicate()[0]
        self.proc = Popen(re.split(r'\s+', command.strip()),
                          universal_newlines=True,
                          stdin=PIPE, stdout=PIPE, stderr=PIPE)
        Log("Start pid %s; %s", self.proc.pid, command)
        self.id = id
        self.inputs = list(inputs)
        self.outputs = []
        self.out_queue = output_queuer(id, self.proc.stdout)
        self.err_queue = output_queuer(id + "(e)", self.proc.stderr)
        self.output_moves = []
        self.input_moves = Queue(MAX_QUEUE_SIZE)  # FIXME:  Was 2
        self.time_limit = time_limit
        self.printing_board = False
        self.finishing = False

    def send_move(self, move):
        """Send SELF the move MOVE, having the form [WB]::cr-cr or
        a "win" message."""
        try:
            self.input_moves.put(move, False)
        except Full:
            self._move_error("other command is not responding")

    def run(self, other):
        """Run my command, using OTHER as the opposing program (None if none)."""
        self.other = other
        self.time_left = { 'B': self.time_limit, 'W': self.time_limit }
        try:
            for inp in self.inputs:
                if Match(r'\s*%(\S*)', inp):
                    self._subcommands.get(Group(1), self._bad_command)(self)
                else:
                    self._await_move(QUANTUM)
                    self._input(inp)
            self._await_move(1.0)
        except Move_Error as excp:
            self._report_termination(excp)
            raise
        except BaseException as excp:
            self._report_termination(Move_Error("%s: terminated on exception (%s)"
                                                % (self.id, repr(excp))))
            raise
        finally:
            self.finish()

    def _win(self, move):
        if Match(r'Tie game\.\s*$', move):
            return "-"
        if not Match(r'.*wins', move):
            return False
        if Match(r'(Black|White) wins\.\s*$', move):
            return Group(1)
        else:
            self._move_error("invalid winner announcement: %s", move.strip())

    def _input(self, line):
        """Send LINE to my process's input."""
        if line[-1] != '\n':
            line += '\n'
        if verbose & 1:
            Msg(">%s: %s", self.id, line)
        try:
            self.proc.stdin.write(line)
            self.proc.stdin.flush()
        except:
            if verbose & 1:
                Msg("%s: process terminated (refused input of '%s')",
                    self.id, line.rstrip())
            raise

    def _add_move(self, m, front = False):
        if front:
            self.output_moves.insert(0, m)
        else:
            self.output_moves.append(m)
        

    def _move_error(self, msg, *args):
        raise Move_Error(self.id + ": " + msg % args)

    def _report_termination(self, excp):
        for i in range(3):
            if self.proc.poll() is not None:
                break
            time.sleep(2*QUANTUM)

        if not excp:
            if self.proc.returncode is None:
                self._move_error("%s: hung", self.id)
            else:
                self._move_error("%s: terminated unexpectedly", self.id)

    def _report_timeout(self, who):
        if who is None:
            self._move_error("game appears to be hung")
        else:
            self._move_error("%s player ran out of time",
                             'black' if who == 'B' else 'white')
        
    def _start_time(self, who):
        self._time0 = time.perf_counter()
        if who:
            return self.time_left[who]

    def _stop_time(self, who):
        self.time_left[who] -= time.perf_counter() - self._time0
        if self.time_left[who] < 0:
            self._report_timeout(who)

    def _process_out(self, line):

        if self.printing_board:
            self.outputs.append(line)
            if Match(r'===\s*$', line):
                self.printing_board = False
            return

        line = re.sub(r'^.*>\s*', '', line)

        if Match(r'===\s*$', line):
            self.printing_board = True
            self.outputs.append(line)
        elif Match(r'\s*([BW]::\S+)\s*$', line):
            self._add_move(Group(1))
        elif Match(r'.*(::|===)', line):
            self._move_error("incorrect use of %s: '%s'", Group(1),
                             line.rstrip())
        elif self._win(line):
            self._add_move(line)

    def _await_move(self, timeout):
        """Wait, processing output, until SELF.output_moves is non-empty
        or TIMEOUT elapses."""
        if not self.output_moves and timeout > 0:
            while True:
                try:
                    err_line = self.err_queue.get_nowait()
                except Empty:
                    break
        while not self.output_moves and timeout > 0:
            time0 = time.perf_counter()
            try:
                self._process_out(self.out_queue.get(True, QUANTUM))
            except Empty:
                pass
            timeout -= time.perf_counter() - time0
            if self._finishing():
                break

    def _get_remote_move(self, who, allow_end, timeout=None):
        time_left = self._start_time(who)
        if timeout is None:
            timeout = time_left
        else:
            timeout = min(timeout, time_left)
        try:
            if timeout <= 0:
                raise Empty
            m = self.input_moves.get(True, timeout)
        except Empty:
            self._move_error("remote player timed out")
        finally:
            self._stop_time(who)
        if self._finishing():
            self._move_error("process shut down")

        if self._win(m):
            if allow_end:
                return m
            else:
                self._move_error("unexpected end of game received")
        if not m or m[0] != who:
            self._move_error("received remote move for wrong player: %s", m)
        if len(m) != 8:
            self._move_error("received incorrectly formatted move")
        return m

    def _get_local_move(self, who, timeout=None):
        if who:
            time_left = self._start_time(who)
            if timeout is None:
                timeout = time_left
            else:
                timeout = min(timeout, time_left)
            self._start_time(who)
            self._await_move(timeout)
            self._stop_time(who)
        else:
            self._await_move(6.0)
        if not self.output_moves:
            self._report_timeout(who)
        m = self.output_moves.pop(0)
            
        if self._win(m):
            return m
        elif not m or m[0] != who:
            self._move_error("received local move for wrong player: %s", m)
        if len(m) != 8:
            self._move_error("received incorrectly formatted move")
        return m

    def _bad_command(self):
        raise Spec_Error('bad command')

    def ib1(self):
        self._await_move(2*QUANTUM)
        self._input(self._get_remote_move('B', False)[3:])

    def iw1(self):
        self._await_move(2*QUANTUM)
        self._input(self._get_remote_move('W', False)[3:])

    def mb(self):
        m = self._get_local_move('B')
        if self._win(m):
            self._move_error("game ends unexpectedly")
        if self.other:
            self.other.send_move(m)
            
    def mw(self):
        m = self._get_local_move('W')
        if self._win(m):
            self._move_error("game ends unexpectedly")
        if self.other:
            self.other.send_move(m)

    def bw(self):
        while True:
            m = self._get_local_move('B')
            if self._win(m):
                self._add_move(m, front=True)
                return
            m = self._get_local_move('W')
            if self._win(m):
                self._add_move(m, front=True)
                return

    def wb(self):
        while True:
            m = self._get_local_move('W')
            if self._win(m):
                self._add_move(m, front=True)
                return
            m = self._get_local_move('B')
            if self._win(m):
                self._add_move(m, front=True)
                return

    def ibn(self):
        self.ib1()
        while True:
            m = self._get_local_move('W')
            self.other.send_move(m)
            if self._win(m):
                self._add_move(m, front=True)
                return
            m = self._get_remote_move('B', True)
            if self._win(m):
                return
            else:
                self._input(m[3:])
        
    def iwn(self):
        self.iw1()
        while True:
            m = self._get_local_move('B')
            self.other.send_move(m)
            if self._win(m):
                self._add_move(m, front=True)
                return
            m = self._get_remote_move('W', True)
            if self._win(m):
                return
            else:
                self._input(m[3:])

    def e(self):
        m = self._get_local_move(None)
        if not self._win(m):
            self._move_error("end of game expected, but not received")

    def eb(self):
        m = self._get_local_move(None)
        w = self._win(m)
        if not w:
            self._move_error("end of game expected, but not received")
        elif w != 'Black':
            self._move_error("expected win for Black")


    def ew(self):
        m = self._get_local_move(None)
        w = self._win(m)
        if not w:
            self._move_error("end of game expected, but not received")
        elif w != 'White':
            self._move_error("expected win for White")

    def et(self):
        m = self._get_local_move(None)
        w = self._win(m)
        if not w:
            self._move_error("end of game expected, but not received")
        elif w != '-':
            self._move_error("expected tie game")

    def ae(self):
        m = self._get_local_move(None)
        w = self._win(m)
        if not w:
            self._move_error("end of game expected, but not received")
        else:
            raise Win(w + " wins")

    _subcommands = { 'ib': ib1, 'iw': iw1, 'mb': mb, 'mw': mw,
                     'bw': bw, 'wb': wb, 
                     'ib...': ibn, 'iw...': iwn,
                     'e': e, 'eb': eb, 'ew': ew, 'et': et, 'ae': ae }

    def procDone(self):
        if self.proc is None:
            return False
        return self.proc.poll()

    def _finishing(self):
        return self.finishing or self.proc.poll() is not None

    def finish(self):
        proc = self.proc
        if proc is None:
            return
        Close(proc.stdin)
        try:
            self._await_move(2*QUANTUM)
        except:
            pass
        time.sleep(2*QUANTUM)
        Close(proc.stdout)
        Close(proc.stderr)
        self.finishing = True
        if proc.poll() is None:
            try:
                Log("kill pid %s", proc.pid)
                os.kill(proc.pid, signal.SIGKILL)
            except:
                Log("failed to kill pid %s", proc.pid)
            try:
                Log("wait for pid %s", proc.pid)
                proc.wait()
            except:
                Log("wait for pid %s failed", proc.pid)
        else:
            Log("proc poll on pid %s succeeded", proc.pid)
        return proc.returncode

def parse_spec(name):
    """Read FILE and return the specified test as a tuple:
       (OPTIONS1, OPTIONS2, INPUTS1, INPUTS2, MAXTIME)."""
    inp = Open(name)
    if inp is None:
        raise Spec_Error("test file does not exist")
    def read_next():
        while True:
            line = inp.readline()
            if line == '':
                return ''
            if not Match(r'\s*#|\s*$', line):
                return line.strip()
            
    try:
        command1 = read_next()
        command2 = read_next()
        if command2 == '':
            raise Spec_Error("truncated specification")
        sep = read_next()
        if sep != '===#1===':
            raise Spec_Error("bad input separator")
        inputs1 = []
        while True:
            line = inp.readline()
            if line == '' and command2 != "None":
                raise Spec_Error("truncated input")
            elif line == '' or line == '===#2===\n':
                break
            inputs1.append(line)
        inputs2 = []
        while True:
            line = inp.readline()
            if line == '':
                break
            inputs2.append(line)

        if Match(r'.*--time=([-\d.]+)', command1):
            time1 = float(Group(1)) * 60.0
        else:
            time1 = move_timeout
        if command2 == 'None':
            time2 = 0.0
        elif Match(r'.*--time=([-\d.]+)', command2):
            time2 = float(Group(1)) * 60.0
        else:
            time2 = move_timeout

        return command1, command2, inputs1, inputs2, max(time1, time2)
    finally:
        Close(inp)

def run_test(test, std):
    terminating = [ False, False ]
    command1, command2, inputs1, inputs2, time_limit = parse_spec(test)
    progs = [ None, None ]
    progs[0] = Prog("Program 1", command1, inputs1, time_limit)
    if command2 == 'None':
        progs[1] = None
    else:
        progs[1] = Prog("Program 2", command2, inputs2, time_limit)

    def prog_thread(k):
        p = progs[k]
        if p is None:
            return
        try:
            p.run(progs[1-k])
            terminating[k] = True
        except Move_Error as e:
            terminating[k] = e
        except Win as e:
            terminating[k] = e
        except BaseException as e:
            if len(e.args) == 1:
                terminating[k] = Move_Error(e.args[0])
            else:
                terminating[k] = Move_Error(repr(e))
            # traceback.print_tb(sys.exc_info()[2])
        
    def convert(lines):
        return '\n'.join(map(lambda s: s.strip(), lines)) + '\n'

    t1 = threading.Thread(target=prog_thread, args=(0,))
    t2 = threading.Thread(target=prog_thread, args=(1,))
    t1.start()
    t2.start()
    time0 = time.perf_counter()
    limit = 2.25 * time_limit + 5.0
    while True:
        t1.join(2*QUANTUM)
        t2.join(2*QUANTUM)
        elapsed = time.perf_counter() - time0
        code = None
        if elapsed > limit or terminating[0] or terminating[1] \
           or progs[0].procDone() or (progs[1] and progs[1].procDone()):
            if elapsed > limit:
                Msg("overall time limit exceeded.")
            progs[0].finish()            
            if progs[1]:
                progs[1].finish()
            break

    if progs[0].procDone() not in [0, -9]:
        raise Move_Error("Program #1 terminated with code %s" %
                         progs[0].procDone())
    if progs[1] and progs[1].procDone() not in [0, -9]:
        raise Move_Error("Program #2 terminated with code %s" %
                         progs[1].procDone())

    if type(terminating[0]) is not bool:
        raise terminating[0]
    if type(terminating[1]) is not bool:
        raise terminating[1]
    outputs = ["Program #1:\n"] + progs[0].outputs
    if progs[1] is not None:
        outputs += ["Program #2:\n"]
        outputs += progs[1].outputs
    if make_std:
        new_std = open(std + ".tmp", "w")
        for line in outputs:
            print(line.rstrip(), file=new_std)
        new_std.close()
    output = convert(outputs)
    stdfile = Open(std)
    if stdfile is not None:
        std_output = convert(stdfile.readlines())
        stdfile.close()
        if output != std_output:
            if verbose & 1:
                Msg("output = \n%s\n", output)
            raise Move_Error("wrong output")

def run_tests(files, show):
    fail = spec_errs = 0
    for test in args:
        name = os.path.splitext(os.path.basename(test))[0]
        std = os.path.join(os.path.dirname(test), name + ".out")
        try:
            run_test(test, std)
            msg = "OK"
        except Spec_Error as e:
            msg = "ERROR (%s)" % e.args[0]
            spec_errs += 1
        except Move_Error as e:
            msg = "FAIL (%s)" % e.args[0]
            fail += 1
            if show and show > 0:
                inp = open(test)
                msg += "\ntest-loa input file:" \
                       + "\n===================================\n" \
                       + inp.read().rstrip() \
                       + "\n===================================" 
                show -= 1
                inp.close()
            elif show == 0:
                msg += " [input file not shown]"
        except Win as e:
            msg = e.args[0]
        print("%s: %s" % (name, msg))
        sys.stdout.flush()

    if fail == 0:
        print("Passed all %d tests." % (len(args) - spec_errs,))
    else:
        print("Failed %d out of %d tests" % (fail, len(args) - spec_errs))
    if spec_errs:
        print("%d tests had missing or erroneous specification files."
              % (spec_errs,))
    sys.exit(fail)

try:
    opts, args = getopt(sys.argv[1:], '',
                        ['verbose', 'verbosity=', 'show=', 'time=', 'std',
                         'log='])
except:
    Usage()

move_timeout = DEFAULT_TIMEOUT
verbose = 0
show = None
make_std = False
log = None
for opt, val in opts:
    if opt == '--verbose':
        verbose = verbose or 1
    elif opt == '--verbosity':
        verbose=int(val)
    elif opt == '--time':
        try:
            move_timeout = float(val) * 60.0
        except:
            Usage()
    elif opt == '--show':
        show = int(val)
    elif opt == '--std':
        make_std = True
    elif opt == '--log':
        try:
            log = open(val, "w")
        except IOError as e:
            print("Could not open log file:", e[1], file=sys.stderr)
            sys.exit(1)

if not args:
    Usage()


try:
    run_tests(args, show)
finally:
    if log:
        log.close()

